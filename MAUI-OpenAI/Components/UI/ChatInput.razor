@inject IPlatformService PlatformService
@inject ITokenizerService TokenizerService
@inject IChatInputService ChatInputService
@inject IBaseService BaseService
@inject IJSRuntime JS
@inject IInputStateService InputStateService

<div class="@ChatInputService.GetFormContainerCssClass(isFocused, platform) relative">
    <form @onsubmit="HandleSubmitAsync" class="flex w-full relative">
        <div class="absolute left-1 top-1 p-1 bg-opacity-75 backdrop-blur-md rounded">
            <span class="@(TokenCount >= MaxTokens ? "text-red" : "text-brightWhite")">
                @TokenCount / @MaxTokens Tokens
                <i @onclick="OpenModal" class="fas fa-info-circle cursor-pointer"></i>
            </span>
        </div>
        <textarea
            @ref="textAreaRef"
            @bind="UserMessage"
            @oninput="HandleInput"
            @onfocus="HandleInputFocus"
            @onblur="HandleInputBlur"
            disabled="@IsInputDisabled"
            placeholder="Type your message or prompt here"
            class="flex-grow p-4 pt-10 px-10 rounded border border-gray focus:outline-none bg-input text-brightWhite h-28 resize-none disabled:cursor-not-allowed disabled:opacity-50"
            maxlength="@(MaxTokens * CharactersPerToken)"
        ></textarea>
        <button
            @onclick="ClearMessagesAsync"
            type="button"
            disabled="@IsInputDisabled"
            class="absolute left-2 bottom-2 text-brightWhite p-2 rounded-full hover:text-brightRed focus:outline-none disabled:cursor-not-allowed disabled:opacity-50"
        >
            <i class="fas fa-trash"></i>
        </button>
        <button
            @onclick="ToggleImageGenerationAsync"
            type="button"
            disabled="@IsInputDisabled"
            class="absolute right-2 top-2 text-brightWhite p-2 rounded-full hover:text-brightBlue focus:outline-none disabled:cursor-not-allowed disabled:opacity-50"
        >
            @if (IsImageGenerationMode)
            {
                <i class="fas fa-image"></i>
            }
            else
            {
                <i class="fas fa-envelope"></i>
            }
        </button>
        <button
            type="submit"
            disabled="@(IsInputDisabled || string.IsNullOrWhiteSpace(UserMessage))"
            class="absolute right-2 bottom-2 text-brightWhite p-2 rounded-full hover:text-brightBlue focus:outline-none disabled:cursor-not-allowed disabled:opacity-50"
        >
            <i class="fa-solid fa-paper-plane"></i>
        </button>
    </form>
    @if (showModal)
    {
        <Modal
            MarkupContent="@modalContent"
            OnClose="HandleModalClose"
            OnError="HandleError"
        />
    }
</div>

@code {
    private ElementReference textAreaRef;
    private bool shouldRegainFocus = false;
    private bool isFocused = false;
    private string platform = "";

    [Parameter]
    public string? UserMessage { get; set; }
    [Parameter]
    public bool IsSendingMessage { get; set; }
    [Parameter]
    public bool IsImageLoading { get; set; } = false;
    [Parameter]
    public bool IsImageGenerationMode { get; set; } = false;
    [Parameter]
    public bool IsAppearanceLoading { get; set; } = false;
    [Parameter]
    public int TokenCount { get; set; }
    [Parameter]
    public int MaxTokens { get; set; }
    [Parameter]
    public double CharactersPerToken { get; set; }
    [Parameter]
    public EventCallback<string> OnSendMessage { get; set; }
    [Parameter]
    public EventCallback<bool> OnToggleImageGeneration { get; set; }
    [Parameter]
    public EventCallback OnClearMessages { get; set; }
    [Parameter]
    public EventCallback<string> OnError { get; set; }

    private bool showModal = false;
    private string modalContent = string.Empty;
    private bool IsInputDisabled => InputStateService.IsInputDisabled(IsSendingMessage, IsImageLoading, IsAppearanceLoading, TokenCount, MaxTokens);

    protected override void OnInitialized()
    {
        try
        {
            platform = PlatformService.GetPlatform(EventCallback.Factory.Create<string>(this, HandleError));
        }
        catch (Exception ex)
        {
            platform = "Unknown Platform";
            BaseService.HandleError($"Failed to get platform information: {ex.Message}", OnError);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (shouldRegainFocus && !isFocused && !IsSendingMessage && !IsImageLoading)
        {
            await ChatInputService.FocusTextAreaAsync(textAreaRef, JS);
        }
    }

    private async Task HandleSubmitAsync()
    {
        await ChatInputService.HandleSubmitAsync(UserMessage ?? string.Empty, OnSendMessage, OnError);
        await ClearInputAsync();
    }

    private async Task ClearMessagesAsync()
    {
        await ChatInputService.ClearMessagesAsync(OnClearMessages, OnError);
        await ClearInputAsync();
    }

    private async Task ToggleImageGenerationAsync()
    {
        await ChatInputService.ToggleImageGenerationAsync(IsImageGenerationMode, OnToggleImageGeneration, OnError);
    }

    private async Task ClearInputAsync()
    {
        await Task.Yield(); // This makes the method asynchronous
        UserMessage = string.Empty;
        TokenCount = 0;
        BaseService.HandleError("", OnError);
        shouldRegainFocus = true;
        StateHasChanged();
    }

    private void HandleInputFocus()
    {
        try
        {
            isFocused = true;
            shouldRegainFocus = false;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            BaseService.HandleError($"Error handling input focus: {ex.Message}", OnError);
        }
    }

    private void HandleInputBlur()
    {
        try
        {
            isFocused = false;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            BaseService.HandleError($"Error handling input blur: {ex.Message}", OnError);
        }
    }

    private void HandleInput(ChangeEventArgs e)
    {
        UserMessage = e.Value?.ToString() ?? string.Empty;
        var chatMessage = new ChatMessageModel(UserMessage, "user");
        TokenCount = chatMessage.EstimateTokenCount(OnError);
    }

    private void HandleError(string message)
    {
        BaseService.HandleError(message, OnError);
    }

    private void OpenModal()
    {
        try
        {
            modalContent = GetTokenInfoMarkup();
            showModal = true;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            HandleError($"Error opening modal: {ex.Message}");
        }
    }

    private void HandleModalClose()
    {
        try
        {
            showModal = false;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            HandleError($"Error closing modal: {ex.Message}");
        }
    }

    private string GetTokenInfoMarkup()
    {
        return @"
            <h2>Understanding Tokens</h2>
            <p>Tokens can be thought of as pieces of words. Before processing a request, the input is broken down into tokens. These tokens can include trailing spaces and even sub-words.</p>
            <p>Here are some helpful rules of thumb for understanding tokens in terms of lengths:</p>
            <ul>
                <li>1 token ≈ 4 characters in English</li>
                <li>1 token ≈ ¾ words</li>
                <li>100 tokens ≈ 75 words</li>
                <li>1-2 sentences ≈ 30 tokens</li>
                <li>1 paragraph ≈ 100 tokens</li>
                <li>1,500 words ≈ 2048 tokens</li>
                <li>Note: The token count is an estimate and may vary.</li>
            </ul>
            <p>For example:</p>
            <ul>
                <li>Wayne Gretzky&apos;s quote “You miss 100% of the shots you don&apos;t take” contains 11 tokens.</li>
                <li>The US Declaration of Independence contains 1,695 tokens.</li>
            </ul>
            <p>The tokenization process varies between languages.</p>
        ";
    }
}